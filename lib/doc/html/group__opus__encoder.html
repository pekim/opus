<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Opus: Opus Encoder</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 64px;">
  <td style="padding-left: 0.5em;">
  <div id="projectname"><img src="opus_logo.svg" width=112 height=64 alt="Opus"/><!--Opus--></div>
  </td>
  <td><table style="padding-left: 0.5em;" cellspacing="0" cellpadding="0"><tbody>
   <tr><td>
   <div id="projectbrief">Opus audio codec (RFC 6716): API and operations manual</div>
   </td></tr>
  <td><span id="projectnumber">1.5.1</span>
   </td></tr>
   </table>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Opus Encoder</div></div>
</div><!--header-->
<div class="contents">

<p>This page describes the process and functions used to encode Opus.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf461a3ef2f10c2fe8b994a176f06c9bd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a></td></tr>
<tr class="memdesc:gaf461a3ef2f10c2fe8b994a176f06c9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opus encoder state.  <br /></td></tr>
<tr class="separator:gaf461a3ef2f10c2fe8b994a176f06c9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaefeb7dc1d6e3b59dea5ea674c86e9c18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__encoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18">opus_encoder_get_size</a> (int channels)</td></tr>
<tr class="memdesc:gaefeb7dc1d6e3b59dea5ea674c86e9c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of an <code>OpusEncoder</code> structure.  <br /></td></tr>
<tr class="separator:gaefeb7dc1d6e3b59dea5ea674c86e9c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0720d9d1efff65b905a64226a81070ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff">opus_encoder_create</a> (<a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> Fs, int channels, int application, int *error)</td></tr>
<tr class="memdesc:ga0720d9d1efff65b905a64226a81070ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes an encoder state.  <br /></td></tr>
<tr class="separator:ga0720d9d1efff65b905a64226a81070ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga515db1c267a7421dacaad3610f79eb79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__encoder.html#ga515db1c267a7421dacaad3610f79eb79">opus_encoder_init</a> (<a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> Fs, int channels, int application)</td></tr>
<tr class="memdesc:ga515db1c267a7421dacaad3610f79eb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a previously allocated encoder state The memory pointed to by st must be at least the size returned by <a class="el" href="group__opus__encoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18" title="Gets the size of an OpusEncoder structure.">opus_encoder_get_size()</a>.  <br /></td></tr>
<tr class="separator:ga515db1c267a7421dacaad3610f79eb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d6bf6a9ffb6674879d7605ed073e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__encoder.html#gad2d6bf6a9ffb6674879d7605ed073e25">opus_encode</a> (<a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st, const <a class="el" href="opus__types_8h.html#acc9ed7cf60479eb81f9648c6ec27dc26">opus_int16</a> *pcm, int frame_size, unsigned char *data, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> max_data_bytes)</td></tr>
<tr class="memdesc:gad2d6bf6a9ffb6674879d7605ed073e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes an Opus frame.  <br /></td></tr>
<tr class="separator:gad2d6bf6a9ffb6674879d7605ed073e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae9905859cd241ef4bb5c59cd5e5309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__encoder.html#ga4ae9905859cd241ef4bb5c59cd5e5309">opus_encode_float</a> (<a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st, const float *pcm, int frame_size, unsigned char *data, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> max_data_bytes)</td></tr>
<tr class="memdesc:ga4ae9905859cd241ef4bb5c59cd5e5309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes an Opus frame from floating point input.  <br /></td></tr>
<tr class="separator:ga4ae9905859cd241ef4bb5c59cd5e5309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f4c05b4b51cdffec5a55dbf17bbfa1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__encoder.html#ga5f4c05b4b51cdffec5a55dbf17bbfa1c">opus_encoder_destroy</a> (<a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st)</td></tr>
<tr class="memdesc:ga5f4c05b4b51cdffec5a55dbf17bbfa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an <code>OpusEncoder</code> allocated by <a class="el" href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff" title="Allocates and initializes an encoder state.">opus_encoder_create()</a>.  <br /></td></tr>
<tr class="separator:ga5f4c05b4b51cdffec5a55dbf17bbfa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164cbb0425238961919adf1db67949df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__encoder.html#ga164cbb0425238961919adf1db67949df">opus_encoder_ctl</a> (<a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st, int request,...)</td></tr>
<tr class="memdesc:ga164cbb0425238961919adf1db67949df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a CTL function on an Opus encoder.  <br /></td></tr>
<tr class="separator:ga164cbb0425238961919adf1db67949df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This page describes the process and functions used to encode Opus. </p>
<p>Since Opus is a stateful codec, the encoding process starts with creating an encoder state. This can be done with:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>          error;</div>
<div class="line"><a class="code hl_typedef" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *enc;</div>
<div class="line">enc = <a class="code hl_function" href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff">opus_encoder_create</a>(Fs, channels, application, &amp;error);</div>
<div class="ttc" id="agroup__opus__encoder_html_ga0720d9d1efff65b905a64226a81070ff"><div class="ttname"><a href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff">opus_encoder_create</a></div><div class="ttdeci">OpusEncoder * opus_encoder_create(opus_int32 Fs, int channels, int application, int *error)</div><div class="ttdoc">Allocates and initializes an encoder state.</div></div>
<div class="ttc" id="agroup__opus__encoder_html_gaf461a3ef2f10c2fe8b994a176f06c9bd"><div class="ttname"><a href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a></div><div class="ttdeci">struct OpusEncoder OpusEncoder</div><div class="ttdoc">Opus encoder state.</div><div class="ttdef"><b>Definition</b> opus.h:164</div></div>
</div><!-- fragment --><p>From this point, <code>enc</code> can be used for encoding an audio stream. An encoder state <b>must</b> <b>not</b> be used for more than one stream at the same time. Similarly, the encoder state <b>must</b> <b>not</b> be re-initialized for each frame.</p>
<p>While <a class="el" href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff" title="Allocates and initializes an encoder state.">opus_encoder_create()</a> allocates memory for the state, it's also possible to initialize pre-allocated memory:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>          size;</div>
<div class="line"><span class="keywordtype">int</span>          error;</div>
<div class="line"><a class="code hl_typedef" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *enc;</div>
<div class="line">size = <a class="code hl_function" href="group__opus__encoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18">opus_encoder_get_size</a>(channels);</div>
<div class="line">enc = malloc(size);</div>
<div class="line">error = <a class="code hl_function" href="group__opus__encoder.html#ga515db1c267a7421dacaad3610f79eb79">opus_encoder_init</a>(enc, Fs, channels, application);</div>
<div class="ttc" id="agroup__opus__encoder_html_ga515db1c267a7421dacaad3610f79eb79"><div class="ttname"><a href="group__opus__encoder.html#ga515db1c267a7421dacaad3610f79eb79">opus_encoder_init</a></div><div class="ttdeci">int opus_encoder_init(OpusEncoder *st, opus_int32 Fs, int channels, int application)</div><div class="ttdoc">Initializes a previously allocated encoder state The memory pointed to by st must be at least the siz...</div></div>
<div class="ttc" id="agroup__opus__encoder_html_gaefeb7dc1d6e3b59dea5ea674c86e9c18"><div class="ttname"><a href="group__opus__encoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18">opus_encoder_get_size</a></div><div class="ttdeci">int opus_encoder_get_size(int channels)</div><div class="ttdoc">Gets the size of an OpusEncoder structure.</div></div>
</div><!-- fragment --><p>where <a class="el" href="group__opus__encoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18" title="Gets the size of an OpusEncoder structure.">opus_encoder_get_size()</a> returns the required size for the encoder state. Note that future versions of this code may change the size, so no assumptions should be made about it.</p>
<p>The encoder state is always continuous in memory and only a shallow copy is sufficient to copy it (e.g. memcpy())</p>
<p>It is possible to change some of the encoder's settings using the <a class="el" href="group__opus__encoder.html#ga164cbb0425238961919adf1db67949df" title="Perform a CTL function on an Opus encoder.">opus_encoder_ctl()</a> interface. All these settings already default to the recommended value, so they should only be changed when necessary. The most common settings one may want to change are:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__opus__encoder.html#ga164cbb0425238961919adf1db67949df">opus_encoder_ctl</a>(enc, <a class="code hl_define" href="group__opus__encoderctls.html#ga0bb51947e355b33d0cb358463b5101a7">OPUS_SET_BITRATE</a>(bitrate));</div>
<div class="line"><a class="code hl_function" href="group__opus__encoder.html#ga164cbb0425238961919adf1db67949df">opus_encoder_ctl</a>(enc, <a class="code hl_define" href="group__opus__encoderctls.html#ga3483877bf1687a75dd4a1de6f85f291c">OPUS_SET_COMPLEXITY</a>(complexity));</div>
<div class="line"><a class="code hl_function" href="group__opus__encoder.html#ga164cbb0425238961919adf1db67949df">opus_encoder_ctl</a>(enc, <a class="code hl_define" href="group__opus__encoderctls.html#gaaa87ccee4ae46aa6c9528e03c5122b89">OPUS_SET_SIGNAL</a>(signal_type));</div>
<div class="ttc" id="agroup__opus__encoder_html_ga164cbb0425238961919adf1db67949df"><div class="ttname"><a href="group__opus__encoder.html#ga164cbb0425238961919adf1db67949df">opus_encoder_ctl</a></div><div class="ttdeci">int opus_encoder_ctl(OpusEncoder *st, int request,...)</div><div class="ttdoc">Perform a CTL function on an Opus encoder.</div></div>
<div class="ttc" id="agroup__opus__encoderctls_html_ga0bb51947e355b33d0cb358463b5101a7"><div class="ttname"><a href="group__opus__encoderctls.html#ga0bb51947e355b33d0cb358463b5101a7">OPUS_SET_BITRATE</a></div><div class="ttdeci">#define OPUS_SET_BITRATE(x)</div><div class="ttdoc">Configures the bitrate in the encoder.</div><div class="ttdef"><b>Definition</b> opus_defines.h:289</div></div>
<div class="ttc" id="agroup__opus__encoderctls_html_ga3483877bf1687a75dd4a1de6f85f291c"><div class="ttname"><a href="group__opus__encoderctls.html#ga3483877bf1687a75dd4a1de6f85f291c">OPUS_SET_COMPLEXITY</a></div><div class="ttdeci">#define OPUS_SET_COMPLEXITY(x)</div><div class="ttdoc">Configures the encoder's computational complexity.</div><div class="ttdef"><b>Definition</b> opus_defines.h:270</div></div>
<div class="ttc" id="agroup__opus__encoderctls_html_gaaa87ccee4ae46aa6c9528e03c5122b89"><div class="ttname"><a href="group__opus__encoderctls.html#gaaa87ccee4ae46aa6c9528e03c5122b89">OPUS_SET_SIGNAL</a></div><div class="ttdeci">#define OPUS_SET_SIGNAL(x)</div><div class="ttdoc">Configures the type of signal being encoded.</div><div class="ttdef"><b>Definition</b> opus_defines.h:438</div></div>
</div><!-- fragment --><p>where</p>
<ul>
<li>bitrate is in bits per second (b/s) </li>
<li>complexity is a value from 1 to 10, where 1 is the lowest complexity and 10 is the highest </li>
<li>signal_type is either OPUS_AUTO (default), OPUS_SIGNAL_VOICE, or OPUS_SIGNAL_MUSIC</li>
</ul>
<p>See <a class="el" href="group__opus__encoderctls.html">Encoder related CTLs</a> and <a class="el" href="group__opus__genericctls.html">Generic CTLs</a> for a complete list of parameters that can be set or queried. Most parameters can be set or changed at any time during a stream.</p>
<p>To encode a frame, <a class="el" href="group__opus__encoder.html#gad2d6bf6a9ffb6674879d7605ed073e25" title="Encodes an Opus frame.">opus_encode()</a> or <a class="el" href="group__opus__encoder.html#ga4ae9905859cd241ef4bb5c59cd5e5309" title="Encodes an Opus frame from floating point input.">opus_encode_float()</a> must be called with exactly one frame (2.5, 5, 10, 20, 40 or 60 ms) of audio data: </p><div class="fragment"><div class="line">len = <a class="code hl_function" href="group__opus__encoder.html#gad2d6bf6a9ffb6674879d7605ed073e25">opus_encode</a>(enc, audio_frame, frame_size, packet, max_packet);</div>
<div class="ttc" id="agroup__opus__encoder_html_gad2d6bf6a9ffb6674879d7605ed073e25"><div class="ttname"><a href="group__opus__encoder.html#gad2d6bf6a9ffb6674879d7605ed073e25">opus_encode</a></div><div class="ttdeci">opus_int32 opus_encode(OpusEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)</div><div class="ttdoc">Encodes an Opus frame.</div></div>
</div><!-- fragment --><p>where </p><ul>
<li>
audio_frame is the audio data in opus_int16 (or float for <a class="el" href="group__opus__encoder.html#ga4ae9905859cd241ef4bb5c59cd5e5309" title="Encodes an Opus frame from floating point input.">opus_encode_float()</a>) </li>
<li>
frame_size is the duration of the frame in samples (per channel) </li>
<li>
packet is the byte array to which the compressed data is written </li>
<li>
max_packet is the maximum number of bytes that can be written in the packet (4000 bytes is recommended). Do not use max_packet to control VBR target bitrate, instead use the <a class="el" href="group__opus__encoderctls.html#ga0bb51947e355b33d0cb358463b5101a7" title="Configures the bitrate in the encoder.">OPUS_SET_BITRATE</a> CTL. </li>
</ul>
<p><a class="el" href="group__opus__encoder.html#gad2d6bf6a9ffb6674879d7605ed073e25" title="Encodes an Opus frame.">opus_encode()</a> and <a class="el" href="group__opus__encoder.html#ga4ae9905859cd241ef4bb5c59cd5e5309" title="Encodes an Opus frame from floating point input.">opus_encode_float()</a> return the number of bytes actually written to the packet. The return value <b>can be negative</b>, which indicates that an error has occurred. If the return value is 2 bytes or less, then the packet does not need to be transmitted (DTX).</p>
<p>Once the encoder state if no longer needed, it can be destroyed with</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__opus__encoder.html#ga5f4c05b4b51cdffec5a55dbf17bbfa1c">opus_encoder_destroy</a>(enc);</div>
<div class="ttc" id="agroup__opus__encoder_html_ga5f4c05b4b51cdffec5a55dbf17bbfa1c"><div class="ttname"><a href="group__opus__encoder.html#ga5f4c05b4b51cdffec5a55dbf17bbfa1c">opus_encoder_destroy</a></div><div class="ttdeci">void opus_encoder_destroy(OpusEncoder *st)</div><div class="ttdoc">Frees an OpusEncoder allocated by opus_encoder_create().</div></div>
</div><!-- fragment --><p>If the encoder was created with <a class="el" href="group__opus__encoder.html#ga515db1c267a7421dacaad3610f79eb79" title="Initializes a previously allocated encoder state The memory pointed to by st must be at least the siz...">opus_encoder_init()</a> rather than <a class="el" href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff" title="Allocates and initializes an encoder state.">opus_encoder_create()</a>, then no action is required aside from potentially freeing the memory that was manually allocated for it (calling free(enc) for the example above) </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf461a3ef2f10c2fe8b994a176f06c9bd" name="gaf461a3ef2f10c2fe8b994a176f06c9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf461a3ef2f10c2fe8b994a176f06c9bd">&#9670;&#160;</a></span>OpusEncoder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> <a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opus encoder state. </p>
<p>This contains the complete state of an Opus encoder. It is position independent and can be freely copied. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff" title="Allocates and initializes an encoder state.">opus_encoder_create</a>,<a class="el" href="group__opus__encoder.html#ga515db1c267a7421dacaad3610f79eb79" title="Initializes a previously allocated encoder state The memory pointed to by st must be at least the siz...">opus_encoder_init</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad2d6bf6a9ffb6674879d7605ed073e25" name="gad2d6bf6a9ffb6674879d7605ed073e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d6bf6a9ffb6674879d7605ed073e25">&#9670;&#160;</a></span>opus_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> opus_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="opus__types_8h.html#acc9ed7cf60479eb81f9648c6ec27dc26">opus_int16</a> *&#160;</td>
          <td class="paramname"><em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&#160;</td>
          <td class="paramname"><em>max_data_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes an Opus frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td><code>OpusEncoder*</code>: Encoder state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcm</td><td><code>opus_int16*</code>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_size</td><td><code>int</code>: Number of samples per channel in the input signal. This must be an Opus frame size for the encoder's sampling rate. For example, at 48 kHz the permitted values are 120, 240, 480, 960, 1920, and 2880. Passing in a duration of less than 10 ms (480 samples at 48 kHz) will prevent the encoder from using the LPC or hybrid modes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td><code>unsigned char*</code>: Output payload. This must contain storage for at least <em>max_data_bytes</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_data_bytes</td><td><code>opus_int32</code>: Size of the allocated memory for the output payload. This may be used to impose an upper limit on the instant bitrate, but should not be used as the only bitrate control. Use <a class="el" href="group__opus__encoderctls.html#ga0bb51947e355b33d0cb358463b5101a7" title="Configures the bitrate in the encoder.">OPUS_SET_BITRATE</a> to control the bitrate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the encoded packet (in bytes) on success or a negative error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </dd></dl>

</div>
</div>
<a id="ga4ae9905859cd241ef4bb5c59cd5e5309" name="ga4ae9905859cd241ef4bb5c59cd5e5309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae9905859cd241ef4bb5c59cd5e5309">&#9670;&#160;</a></span>opus_encode_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> opus_encode_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&#160;</td>
          <td class="paramname"><em>max_data_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes an Opus frame from floating point input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td><code>OpusEncoder*</code>: Encoder state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcm</td><td><code>float*</code>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0. Samples with a range beyond +/-1.0 are supported but will be clipped by decoders using the integer API and should only be used if it is known that the far end supports extended dynamic range. length is frame_size*channels*sizeof(float) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_size</td><td><code>int</code>: Number of samples per channel in the input signal. This must be an Opus frame size for the encoder's sampling rate. For example, at 48 kHz the permitted values are 120, 240, 480, 960, 1920, and 2880. Passing in a duration of less than 10 ms (480 samples at 48 kHz) will prevent the encoder from using the LPC or hybrid modes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td><code>unsigned char*</code>: Output payload. This must contain storage for at least <em>max_data_bytes</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_data_bytes</td><td><code>opus_int32</code>: Size of the allocated memory for the output payload. This may be used to impose an upper limit on the instant bitrate, but should not be used as the only bitrate control. Use <a class="el" href="group__opus__encoderctls.html#ga0bb51947e355b33d0cb358463b5101a7" title="Configures the bitrate in the encoder.">OPUS_SET_BITRATE</a> to control the bitrate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the encoded packet (in bytes) on success or a negative error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </dd></dl>

</div>
</div>
<a id="ga0720d9d1efff65b905a64226a81070ff" name="ga0720d9d1efff65b905a64226a81070ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0720d9d1efff65b905a64226a81070ff">&#9670;&#160;</a></span>opus_encoder_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> * opus_encoder_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&#160;</td>
          <td class="paramname"><em>Fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>application</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an encoder state. </p>
<p>There are three coding modes:</p>
<p><a class="el" href="group__opus__ctlvalues.html#ga07884aa018303a419d1f7acb2f3fa669">OPUS_APPLICATION_VOIP</a> gives best quality at a given bitrate for voice signals. It enhances the input signal by high-pass filtering and emphasizing formants and harmonics. Optionally it includes in-band forward error correction to protect against packet loss. Use this mode for typical VoIP applications. Because of the enhancement, even at high bitrates the output may sound different from the input.</p>
<p><a class="el" href="group__opus__ctlvalues.html#ga5909f7cb35c04f1110026c6889edd345">OPUS_APPLICATION_AUDIO</a> gives best quality at a given bitrate for most non-voice signals like music. Use this mode for music and mixed (music/voice) content, broadcast, and applications requiring less than 15 ms of coding delay.</p>
<p><a class="el" href="group__opus__ctlvalues.html#ga592232fb39db60c1369989c5c5d19a07">OPUS_APPLICATION_RESTRICTED_LOWDELAY</a> configures low-delay mode that disables the speech-optimized mode in exchange for slightly reduced delay. This mode can only be set on an newly initialized or freshly reset encoder because it changes the codec delay.</p>
<p>This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Fs</td><td><code>opus_int32</code>: Sampling rate of input signal (Hz) This must be one of 8000, 12000, 16000, 24000, or 48000. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td><code>int</code>: Number of channels (1 or 2) in input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">application</td><td><code>int</code>: Coding mode (one of <a class="el" href="group__opus__ctlvalues.html#ga07884aa018303a419d1f7acb2f3fa669">OPUS_APPLICATION_VOIP</a>, <a class="el" href="group__opus__ctlvalues.html#ga5909f7cb35c04f1110026c6889edd345">OPUS_APPLICATION_AUDIO</a>, or <a class="el" href="group__opus__ctlvalues.html#ga592232fb39db60c1369989c5c5d19a07">OPUS_APPLICATION_RESTRICTED_LOWDELAY</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td><code>int*</code>: <a class="el" href="group__opus__errorcodes.html">Error codes</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Regardless of the sampling rate and number channels selected, the Opus encoder can switch to a lower audio bandwidth or number of channels if the bitrate selected is too low. This also means that it is safe to always use 48 kHz stereo input and let the encoder optimize the encoding. </dd></dl>

</div>
</div>
<a id="ga164cbb0425238961919adf1db67949df" name="ga164cbb0425238961919adf1db67949df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164cbb0425238961919adf1db67949df">&#9670;&#160;</a></span>opus_encoder_ctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_encoder_ctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a CTL function on an Opus encoder. </p>
<p>Generally the request and subsequent arguments are generated by a convenience macro. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td><code>OpusEncoder*</code>: Encoder state. </td></tr>
    <tr><td class="paramname">request</td><td>This and all remaining parameters should be replaced by one of the convenience macros in <a class="el" href="group__opus__genericctls.html">Generic CTLs</a> or <a class="el" href="group__opus__encoderctls.html">Encoder related CTLs</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__opus__genericctls.html" title="These macros are used with the opus_decoder_ctl and opus_encoder_ctl calls to generate a particular r...">Generic CTLs</a> </dd>
<dd>
<a class="el" href="group__opus__encoderctls.html" title="These are convenience macros for use with the opus_encode_ctl interface.">Encoder related CTLs</a> </dd></dl>

</div>
</div>
<a id="ga5f4c05b4b51cdffec5a55dbf17bbfa1c" name="ga5f4c05b4b51cdffec5a55dbf17bbfa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f4c05b4b51cdffec5a55dbf17bbfa1c">&#9670;&#160;</a></span>opus_encoder_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opus_encoder_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees an <code>OpusEncoder</code> allocated by <a class="el" href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff" title="Allocates and initializes an encoder state.">opus_encoder_create()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td><code>OpusEncoder*</code>: State to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefeb7dc1d6e3b59dea5ea674c86e9c18" name="gaefeb7dc1d6e3b59dea5ea674c86e9c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefeb7dc1d6e3b59dea5ea674c86e9c18">&#9670;&#160;</a></span>opus_encoder_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_encoder_get_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of an <code>OpusEncoder</code> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td><code>int</code>: Number of channels. This must be 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes. </dd></dl>

</div>
</div>
<a id="ga515db1c267a7421dacaad3610f79eb79" name="ga515db1c267a7421dacaad3610f79eb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga515db1c267a7421dacaad3610f79eb79">&#9670;&#160;</a></span>opus_encoder_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_encoder_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__encoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&#160;</td>
          <td class="paramname"><em>Fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>application</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a previously allocated encoder state The memory pointed to by st must be at least the size returned by <a class="el" href="group__opus__encoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18" title="Gets the size of an OpusEncoder structure.">opus_encoder_get_size()</a>. </p>
<p>This is intended for applications which use their own allocator instead of malloc. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__opus__encoder.html#ga0720d9d1efff65b905a64226a81070ff" title="Allocates and initializes an encoder state.">opus_encoder_create()</a>,<a class="el" href="group__opus__encoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18" title="Gets the size of an OpusEncoder structure.">opus_encoder_get_size()</a> To reset a previously initialized state, use the <a class="el" href="group__opus__genericctls.html#gadc74e4fa8bcdf9994187d52d92207337" title="Resets the codec state to be equivalent to a freshly initialized state.">OPUS_RESET_STATE</a> CTL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td><code>OpusEncoder*</code>: Encoder state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fs</td><td><code>opus_int32</code>: Sampling rate of input signal (Hz) This must be one of 8000, 12000, 16000, 24000, or 48000. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td><code>int</code>: Number of channels (1 or 2) in input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">application</td><td><code>int</code>: Coding mode (one of OPUS_APPLICATION_VOIP, OPUS_APPLICATION_AUDIO, or OPUS_APPLICATION_RESTRICTED_LOWDELAY) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__opus__errorcodes.html#gaa44cf8a185e1b5cb940ef63eb4f02d21" title="No error.">OPUS_OK</a></td><td>Success or <a class="el" href="group__opus__errorcodes.html">Error codes</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<hr class="footer"/>
<table width="100%">
  <tbody>
    <tr>
      <td>
For more information visit the <a href="https://opus-codec.org">Opus Website</a>.
      </td>
      <td>
        <address class="footer"><small>
          Generated by
          <a href="http://www.doxygen.org/index.html">doxygen</a>
          1.9.7
        </small></address>
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
