\doxysection{Opus Decoder}
\hypertarget{group__opus__decoder}{}\label{group__opus__decoder}\index{Opus Decoder@{Opus Decoder}}


This page describes the process and functions used to decode Opus.  


\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}}
\begin{DoxyCompactList}\small\item\em Opus decoder state. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}}
\begin{DoxyCompactList}\small\item\em Opus DRED decoder. \end{DoxyCompactList}\item 
typedef struct \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}}
\begin{DoxyCompactList}\small\item\em Opus DRED state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{group__opus__decoder_gac918415b2ee21add75b7f867ce235011}{opus\+\_\+decoder\+\_\+get\+\_\+size}} (int channels)
\begin{DoxyCompactList}\small\item\em Gets the size of an {\ttfamily Opus\+Decoder} structure. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27}{opus\+\_\+decoder\+\_\+create}} (\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} Fs, int channels, int \texorpdfstring{$\ast$}{*}error)
\begin{DoxyCompactList}\small\item\em Allocates and initializes a decoder state. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga939156d1f561c4273d5c62fa9c235a01}{opus\+\_\+decoder\+\_\+init}} (\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}st, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} Fs, int channels)
\begin{DoxyCompactList}\small\item\em Initializes a previously allocated decoder state. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga7d1111f64c36027ddcb81799df9b3fc9}{opus\+\_\+decode}} (\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}st, const unsigned char \texorpdfstring{$\ast$}{*}data, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} len, \mbox{\hyperlink{opus__types_8h_acc9ed7cf60479eb81f9648c6ec27dc26}{opus\+\_\+int16}} \texorpdfstring{$\ast$}{*}pcm, int frame\+\_\+size, int decode\+\_\+fec)
\begin{DoxyCompactList}\small\item\em Decode an Opus packet. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga9c554b8c0214e24733a299fe53bb3bd2}{opus\+\_\+decode\+\_\+float}} (\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}st, const unsigned char \texorpdfstring{$\ast$}{*}data, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} len, float \texorpdfstring{$\ast$}{*}pcm, int frame\+\_\+size, int decode\+\_\+fec)
\begin{DoxyCompactList}\small\item\em Decode an Opus packet with floating point output. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga2d492844b4f66e7f34d85870f13d4846}{opus\+\_\+decoder\+\_\+ctl}} (\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}st, int request,...)
\begin{DoxyCompactList}\small\item\em Perform a CTL function on an Opus decoder. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__opus__decoder_gafebf4cb3c29c9317cac385446a76e36e}{opus\+\_\+decoder\+\_\+destroy}} (\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}st)
\begin{DoxyCompactList}\small\item\em Frees an {\ttfamily Opus\+Decoder} allocated by \doxylink{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27}{opus\+\_\+decoder\+\_\+create()}. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga58665700bd65a64b4cb811dbd4db1e2a}{opus\+\_\+dred\+\_\+decoder\+\_\+get\+\_\+size}} (void)
\begin{DoxyCompactList}\small\item\em Gets the size of an {\ttfamily Opus\+DREDDecoder} structure. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{group__opus__decoder_gaab0b546b5e1bc78da815ff880b410f97}{opus\+\_\+dred\+\_\+decoder\+\_\+create}} (int \texorpdfstring{$\ast$}{*}error)
\begin{DoxyCompactList}\small\item\em Allocates and initializes an Opus\+DREDDecoder state. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_gaefbe97140acff521c3b2d4a1b00b33d5}{opus\+\_\+dred\+\_\+decoder\+\_\+init}} (\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}dec)
\begin{DoxyCompactList}\small\item\em Initializes an {\ttfamily Opus\+DREDDecoder} state. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__opus__decoder_ga21ef5755a25762a69665b1883382292e}{opus\+\_\+dred\+\_\+decoder\+\_\+destroy}} (\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}dec)
\begin{DoxyCompactList}\small\item\em Frees an {\ttfamily Opus\+DREDDecoder} allocated by \doxylink{group__opus__decoder_gaab0b546b5e1bc78da815ff880b410f97}{opus\+\_\+dred\+\_\+decoder\+\_\+create()}. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga2d964d7a37ed634ff6d135c40b05d75f}{opus\+\_\+dred\+\_\+decoder\+\_\+ctl}} (\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}dred\+\_\+dec, int request,...)
\begin{DoxyCompactList}\small\item\em Perform a CTL function on an Opus DRED decoder. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_gaa7c7210fda039d466bcbd28c9a9b081f}{opus\+\_\+dred\+\_\+get\+\_\+size}} (void)
\begin{DoxyCompactList}\small\item\em Gets the size of an {\ttfamily Opus\+DRED} structure. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{group__opus__decoder_ga28952b35cc367f2a334789042f8b378b}{opus\+\_\+dred\+\_\+alloc}} (int \texorpdfstring{$\ast$}{*}error)
\begin{DoxyCompactList}\small\item\em Allocates and initializes a DRED state. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__opus__decoder_ga935b58a831738b44afd2ed42096f0ee9}{opus\+\_\+dred\+\_\+free}} (\mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}dec)
\begin{DoxyCompactList}\small\item\em Frees an {\ttfamily Opus\+DRED} allocated by opus\+\_\+dred\+\_\+create(). \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga6674a62897092f51183a792669b99c6e}{opus\+\_\+dred\+\_\+parse}} (\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}dred\+\_\+dec, \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}dred, const unsigned char \texorpdfstring{$\ast$}{*}data, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} len, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} max\+\_\+dred\+\_\+samples, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} sampling\+\_\+rate, int \texorpdfstring{$\ast$}{*}dred\+\_\+end, int defer\+\_\+processing)
\begin{DoxyCompactList}\small\item\em Decode an Opus DRED packet. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_gaf25125c27783db366f239b7ab3633601}{opus\+\_\+dred\+\_\+process}} (\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}dred\+\_\+dec, const \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}src, \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}dst)
\begin{DoxyCompactList}\small\item\em Finish decoding an Opus DRED packet. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_gabae9495fe3fb0750d42b7b85705c12ca}{opus\+\_\+decoder\+\_\+dred\+\_\+decode}} (\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}st, const \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}dred, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} dred\+\_\+offset, \mbox{\hyperlink{opus__types_8h_acc9ed7cf60479eb81f9648c6ec27dc26}{opus\+\_\+int16}} \texorpdfstring{$\ast$}{*}pcm, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} frame\+\_\+size)
\begin{DoxyCompactList}\small\item\em Decode audio from an Opus DRED packet with floating point output. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_gaa2957ee03a4aadc6eda52c040c5d4ac6}{opus\+\_\+decoder\+\_\+dred\+\_\+decode\+\_\+float}} (\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}st, const \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}dred, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} dred\+\_\+offset, float \texorpdfstring{$\ast$}{*}pcm, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} frame\+\_\+size)
\begin{DoxyCompactList}\small\item\em Decode audio from an Opus DRED packet with floating point output. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga9d0054936a3345865632b04729cd368c}{opus\+\_\+packet\+\_\+parse}} (const unsigned char \texorpdfstring{$\ast$}{*}data, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} len, unsigned char \texorpdfstring{$\ast$}{*}out\+\_\+toc, const unsigned char \texorpdfstring{$\ast$}{*}frames\mbox{[}48\mbox{]}, \mbox{\hyperlink{opus__types_8h_acc9ed7cf60479eb81f9648c6ec27dc26}{opus\+\_\+int16}} size\mbox{[}48\mbox{]}, int \texorpdfstring{$\ast$}{*}payload\+\_\+offset)
\begin{DoxyCompactList}\small\item\em Parse an opus packet into one or more frames. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga89b9375b6ff5e15f07fdc5d0cf4f0053}{opus\+\_\+packet\+\_\+get\+\_\+bandwidth}} (const unsigned char \texorpdfstring{$\ast$}{*}data)
\begin{DoxyCompactList}\small\item\em Gets the bandwidth of an Opus packet. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_gab2a955acced631c6cb7876bbdc7953d4}{opus\+\_\+packet\+\_\+get\+\_\+samples\+\_\+per\+\_\+frame}} (const unsigned char \texorpdfstring{$\ast$}{*}data, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} Fs)
\begin{DoxyCompactList}\small\item\em Gets the number of samples per frame from an Opus packet. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga4209376ddf8cc3379767e1749e1ef26d}{opus\+\_\+packet\+\_\+get\+\_\+nb\+\_\+channels}} (const unsigned char \texorpdfstring{$\ast$}{*}data)
\begin{DoxyCompactList}\small\item\em Gets the number of channels from an Opus packet. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga064cb2ed9e77a934cd7db6c13b02c584}{opus\+\_\+packet\+\_\+get\+\_\+nb\+\_\+frames}} (const unsigned char packet\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} len)
\begin{DoxyCompactList}\small\item\em Gets the number of frames in an Opus packet. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga3cfec8b0bed7789ebd88c3b3370d337b}{opus\+\_\+packet\+\_\+get\+\_\+nb\+\_\+samples}} (const unsigned char packet\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} len, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} Fs)
\begin{DoxyCompactList}\small\item\em Gets the number of samples of an Opus packet. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_gae142ef5b2a6c228f8b329646c9403101}{opus\+\_\+packet\+\_\+has\+\_\+lbrr}} (const unsigned char packet\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} len)
\begin{DoxyCompactList}\small\item\em Checks whether an Opus packet has LBRR. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__opus__decoder_ga659135a16060f85908f63443a2325118}{opus\+\_\+decoder\+\_\+get\+\_\+nb\+\_\+samples}} (const \mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}dec, const unsigned char packet\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}} len)
\begin{DoxyCompactList}\small\item\em Gets the number of samples of an Opus packet. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__opus__decoder_gaff99598b352e8939dded08d96e125e0b}{opus\+\_\+pcm\+\_\+soft\+\_\+clip}} (float \texorpdfstring{$\ast$}{*}pcm, int frame\+\_\+size, int channels, float \texorpdfstring{$\ast$}{*}softclip\+\_\+mem)
\begin{DoxyCompactList}\small\item\em Applies soft-\/clipping to bring a float signal within the \mbox{[}-\/1,1\mbox{]} range. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This page describes the process and functions used to decode Opus. 

The decoding process also starts with creating a decoder state. This can be done with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ \ error;}
\DoxyCodeLine{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{OpusDecoder}}\ *dec;}
\DoxyCodeLine{dec\ =\ \mbox{\hyperlink{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27}{opus\_decoder\_create}}(Fs,\ channels,\ \&error);}

\end{DoxyCode}
 where \begin{DoxyItemize}
\item Fs is the sampling rate and must be 8000, 12000, 16000, 24000, or 48000 \item channels is the number of channels (1 or 2) \item error will hold the error code in case of failure (or \doxylink{group__opus__errorcodes_gaa44cf8a185e1b5cb940ef63eb4f02d21}{OPUS\+\_\+\+OK} on success) \item the return value is a newly created decoder state to be used for decoding\end{DoxyItemize}
While \doxylink{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27}{opus\+\_\+decoder\+\_\+create()} allocates memory for the state, it\textquotesingle{}s also possible to initialize pre-\/allocated memory\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ \ size;}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ \ error;}
\DoxyCodeLine{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{OpusDecoder}}\ *dec;}
\DoxyCodeLine{size\ =\ \mbox{\hyperlink{group__opus__decoder_gac918415b2ee21add75b7f867ce235011}{opus\_decoder\_get\_size}}(channels);}
\DoxyCodeLine{dec\ =\ malloc(size);}
\DoxyCodeLine{error\ =\ \mbox{\hyperlink{group__opus__decoder_ga939156d1f561c4273d5c62fa9c235a01}{opus\_decoder\_init}}(dec,\ Fs,\ channels);}

\end{DoxyCode}
 where \doxylink{group__opus__decoder_gac918415b2ee21add75b7f867ce235011}{opus\+\_\+decoder\+\_\+get\+\_\+size()} returns the required size for the decoder state. Note that future versions of this code may change the size, so no assumptions should be made about it.

The decoder state is always continuous in memory and only a shallow copy is sufficient to copy it (e.\+g. memcpy())

To decode a frame, \doxylink{group__opus__decoder_ga7d1111f64c36027ddcb81799df9b3fc9}{opus\+\_\+decode()} or \doxylink{group__opus__decoder_ga9c554b8c0214e24733a299fe53bb3bd2}{opus\+\_\+decode\+\_\+float()} must be called with a packet of compressed audio data\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{frame\_size\ =\ \mbox{\hyperlink{group__opus__decoder_ga7d1111f64c36027ddcb81799df9b3fc9}{opus\_decode}}(dec,\ packet,\ len,\ decoded,\ max\_size,\ 0);}

\end{DoxyCode}
 where

\begin{DoxyItemize}
\item packet is the byte array containing the compressed data \item len is the exact number of bytes contained in the packet \item decoded is the decoded audio data in opus\+\_\+int16 (or float for \doxylink{group__opus__decoder_ga9c554b8c0214e24733a299fe53bb3bd2}{opus\+\_\+decode\+\_\+float()}) \item max\+\_\+size is the max duration of the frame in samples (per channel) that can fit into the decoded\+\_\+frame array\end{DoxyItemize}
\doxylink{group__opus__decoder_ga7d1111f64c36027ddcb81799df9b3fc9}{opus\+\_\+decode()} and \doxylink{group__opus__decoder_ga9c554b8c0214e24733a299fe53bb3bd2}{opus\+\_\+decode\+\_\+float()} return the number of samples (per channel) decoded from the packet. If that value is negative, then an error has occurred. This can occur if the packet is corrupted or if the audio buffer is too small to hold the decoded audio.

Opus is a stateful codec with overlapping blocks and as a result Opus packets are not coded independently of each other. Packets must be passed into the decoder serially and in the correct order for a correct decode. Lost packets can be replaced with loss concealment by calling the decoder with a null pointer and zero length for the missing packet.

A single codec state may only be accessed from a single thread at a time and any required locking must be performed by the caller. Separate streams must be decoded with separate decoder states and can be decoded in parallel unless the library was compiled with NONTHREADSAFE\+\_\+\+PSEUDOSTACK defined. 

\doxysubsection{Typedef Documentation}
\Hypertarget{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}\label{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6} 
\index{Opus Decoder@{Opus Decoder}!OpusDecoder@{OpusDecoder}}
\index{OpusDecoder@{OpusDecoder}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{OpusDecoder}{OpusDecoder}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}}}



Opus decoder state. 

This contains the complete state of an Opus decoder. It is position independent and can be freely copied. \begin{DoxySeeAlso}{See also}
\doxylink{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27}{opus\+\_\+decoder\+\_\+create},\doxylink{group__opus__decoder_ga939156d1f561c4273d5c62fa9c235a01}{opus\+\_\+decoder\+\_\+init} 
\end{DoxySeeAlso}
\Hypertarget{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}\label{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b} 
\index{Opus Decoder@{Opus Decoder}!OpusDRED@{OpusDRED}}
\index{OpusDRED@{OpusDRED}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{OpusDRED}{OpusDRED}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}}}



Opus DRED state. 

This contains the complete state of an Opus DRED packet. It is position independent and can be freely copied. \begin{DoxySeeAlso}{See also}
opus\+\_\+dred\+\_\+create,opus\+\_\+dred\+\_\+init 
\end{DoxySeeAlso}
\Hypertarget{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}\label{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c} 
\index{Opus Decoder@{Opus Decoder}!OpusDREDDecoder@{OpusDREDDecoder}}
\index{OpusDREDDecoder@{OpusDREDDecoder}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{OpusDREDDecoder}{OpusDREDDecoder}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}}}



Opus DRED decoder. 

This contains the complete state of an Opus DRED decoder. It is position independent and can be freely copied. \begin{DoxySeeAlso}{See also}
\doxylink{group__opus__decoder_gaab0b546b5e1bc78da815ff880b410f97}{opus\+\_\+dred\+\_\+decoder\+\_\+create},\doxylink{group__opus__decoder_gaefbe97140acff521c3b2d4a1b00b33d5}{opus\+\_\+dred\+\_\+decoder\+\_\+init} 
\end{DoxySeeAlso}


\doxysubsection{Function Documentation}
\Hypertarget{group__opus__decoder_ga7d1111f64c36027ddcb81799df9b3fc9}\label{group__opus__decoder_ga7d1111f64c36027ddcb81799df9b3fc9} 
\index{Opus Decoder@{Opus Decoder}!opus\_decode@{opus\_decode}}
\index{opus\_decode@{opus\_decode}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decode()}{opus\_decode()}}
{\footnotesize\ttfamily int opus\+\_\+decode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}}]{st,  }\item[{const unsigned char \texorpdfstring{$\ast$}{*}}]{data,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{len,  }\item[{\mbox{\hyperlink{opus__types_8h_acc9ed7cf60479eb81f9648c6ec27dc26}{opus\+\_\+int16}} \texorpdfstring{$\ast$}{*}}]{pcm,  }\item[{int}]{frame\+\_\+size,  }\item[{int}]{decode\+\_\+fec }\end{DoxyParamCaption})}



Decode an Opus packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em st} & {\ttfamily Opus\+Decoder\texorpdfstring{$\ast$}{*}}\+: Decoder state \\
\hline
\mbox{\texttt{ in}}  & {\em data} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Input payload. Use a NULL pointer to indicate packet loss \\
\hline
\mbox{\texttt{ in}}  & {\em len} & {\ttfamily opus\+\_\+int32}\+: Number of bytes in payload\texorpdfstring{$\ast$}{*} \\
\hline
\mbox{\texttt{ out}}  & {\em pcm} & {\ttfamily opus\+\_\+int16\texorpdfstring{$\ast$}{*}}\+: Output signal (interleaved if 2 channels). length is frame\+\_\+size\texorpdfstring{$\ast$}{*}channels\texorpdfstring{$\ast$}{*}sizeof(opus\+\_\+int16) \\
\hline
\mbox{\texttt{ in}}  & {\em frame\+\_\+size} & Number of samples per channel of available space in {\itshape pcm}. If this is less than the maximum packet duration (120ms; 5760 for 48k\+Hz), this function will not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode\+\_\+fec=1), then frame\+\_\+size needs to be exactly the duration of audio that is missing, otherwise the decoder will not be in the optimal state to decode the next incoming packet. For the PLC and FEC cases, frame\+\_\+size {\bfseries{must}} be a multiple of 2.\+5 ms. \\
\hline
\mbox{\texttt{ in}}  & {\em decode\+\_\+fec} & {\ttfamily int}\+: Flag (0 or 1) to request that any in-\/band forward error correction data be decoded. If no such data is available, the frame is decoded as if it were lost. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of decoded samples or \doxylink{group__opus__errorcodes}{Error codes} 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_ga9c554b8c0214e24733a299fe53bb3bd2}\label{group__opus__decoder_ga9c554b8c0214e24733a299fe53bb3bd2} 
\index{Opus Decoder@{Opus Decoder}!opus\_decode\_float@{opus\_decode\_float}}
\index{opus\_decode\_float@{opus\_decode\_float}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decode\_float()}{opus\_decode\_float()}}
{\footnotesize\ttfamily int opus\+\_\+decode\+\_\+float (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}}]{st,  }\item[{const unsigned char \texorpdfstring{$\ast$}{*}}]{data,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{len,  }\item[{float \texorpdfstring{$\ast$}{*}}]{pcm,  }\item[{int}]{frame\+\_\+size,  }\item[{int}]{decode\+\_\+fec }\end{DoxyParamCaption})}



Decode an Opus packet with floating point output. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em st} & {\ttfamily Opus\+Decoder\texorpdfstring{$\ast$}{*}}\+: Decoder state \\
\hline
\mbox{\texttt{ in}}  & {\em data} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Input payload. Use a NULL pointer to indicate packet loss \\
\hline
\mbox{\texttt{ in}}  & {\em len} & {\ttfamily opus\+\_\+int32}\+: Number of bytes in payload \\
\hline
\mbox{\texttt{ out}}  & {\em pcm} & {\ttfamily float\texorpdfstring{$\ast$}{*}}\+: Output signal (interleaved if 2 channels). length is frame\+\_\+size\texorpdfstring{$\ast$}{*}channels\texorpdfstring{$\ast$}{*}sizeof(float) \\
\hline
\mbox{\texttt{ in}}  & {\em frame\+\_\+size} & Number of samples per channel of available space in {\itshape pcm}. If this is less than the maximum packet duration (120ms; 5760 for 48k\+Hz), this function will not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode\+\_\+fec=1), then frame\+\_\+size needs to be exactly the duration of audio that is missing, otherwise the decoder will not be in the optimal state to decode the next incoming packet. For the PLC and FEC cases, frame\+\_\+size {\bfseries{must}} be a multiple of 2.\+5 ms. \\
\hline
\mbox{\texttt{ in}}  & {\em decode\+\_\+fec} & {\ttfamily int}\+: Flag (0 or 1) to request that any in-\/band forward error correction data be decoded. If no such data is available the frame is decoded as if it were lost. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of decoded samples or \doxylink{group__opus__errorcodes}{Error codes} 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27}\label{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27} 
\index{Opus Decoder@{Opus Decoder}!opus\_decoder\_create@{opus\_decoder\_create}}
\index{opus\_decoder\_create@{opus\_decoder\_create}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decoder\_create()}{opus\_decoder\_create()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*} opus\+\_\+decoder\+\_\+create (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{Fs,  }\item[{int}]{channels,  }\item[{int \texorpdfstring{$\ast$}{*}}]{error }\end{DoxyParamCaption})}



Allocates and initializes a decoder state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Fs} & {\ttfamily opus\+\_\+int32}\+: Sample rate to decode at (Hz). This must be one of 8000, 12000, 16000, 24000, or 48000. \\
\hline
\mbox{\texttt{ in}}  & {\em channels} & {\ttfamily int}\+: Number of channels (1 or 2) to decode \\
\hline
\mbox{\texttt{ out}}  & {\em error} & {\ttfamily int\texorpdfstring{$\ast$}{*}}\+: \doxylink{group__opus__errorcodes_gaa44cf8a185e1b5cb940ef63eb4f02d21}{OPUS\+\_\+\+OK} Success or \doxylink{group__opus__errorcodes}{Error codes}\\
\hline
\end{DoxyParams}
Internally Opus stores data at 48000 Hz, so that should be the default value for Fs. However, the decoder can efficiently decode to buffers at 8, 12, 16, and 24 k\+Hz so if for some reason the caller cannot use data at the full sample rate, or knows the compressed data doesn\textquotesingle{}t use the full frequency range, it can request decoding at a reduced rate. Likewise, the decoder is capable of filling in either mono or interleaved stereo pcm buffers, at the caller\textquotesingle{}s request. \Hypertarget{group__opus__decoder_ga2d492844b4f66e7f34d85870f13d4846}\label{group__opus__decoder_ga2d492844b4f66e7f34d85870f13d4846} 
\index{Opus Decoder@{Opus Decoder}!opus\_decoder\_ctl@{opus\_decoder\_ctl}}
\index{opus\_decoder\_ctl@{opus\_decoder\_ctl}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decoder\_ctl()}{opus\_decoder\_ctl()}}
{\footnotesize\ttfamily int opus\+\_\+decoder\+\_\+ctl (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}}]{st,  }\item[{int}]{request,  }\item[{}]{... }\end{DoxyParamCaption})}



Perform a CTL function on an Opus decoder. 

Generally the request and subsequent arguments are generated by a convenience macro. 
\begin{DoxyParams}{Parameters}
{\em st} & {\ttfamily Opus\+Decoder\texorpdfstring{$\ast$}{*}}\+: Decoder state. \\
\hline
{\em request} & This and all remaining parameters should be replaced by one of the convenience macros in \doxylink{group__opus__genericctls}{Generic CTLs} or \doxylink{group__opus__decoderctls}{Decoder related CTLs}. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{group__opus__genericctls}{Generic CTLs} 

\doxylink{group__opus__decoderctls}{Decoder related CTLs} 
\end{DoxySeeAlso}
\Hypertarget{group__opus__decoder_gafebf4cb3c29c9317cac385446a76e36e}\label{group__opus__decoder_gafebf4cb3c29c9317cac385446a76e36e} 
\index{Opus Decoder@{Opus Decoder}!opus\_decoder\_destroy@{opus\_decoder\_destroy}}
\index{opus\_decoder\_destroy@{opus\_decoder\_destroy}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decoder\_destroy()}{opus\_decoder\_destroy()}}
{\footnotesize\ttfamily void opus\+\_\+decoder\+\_\+destroy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}}]{st }\end{DoxyParamCaption})}



Frees an {\ttfamily Opus\+Decoder} allocated by \doxylink{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27}{opus\+\_\+decoder\+\_\+create()}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em st} & {\ttfamily Opus\+Decoder\texorpdfstring{$\ast$}{*}}\+: State to be freed. \\
\hline
\end{DoxyParams}
\Hypertarget{group__opus__decoder_gabae9495fe3fb0750d42b7b85705c12ca}\label{group__opus__decoder_gabae9495fe3fb0750d42b7b85705c12ca} 
\index{Opus Decoder@{Opus Decoder}!opus\_decoder\_dred\_decode@{opus\_decoder\_dred\_decode}}
\index{opus\_decoder\_dred\_decode@{opus\_decoder\_dred\_decode}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decoder\_dred\_decode()}{opus\_decoder\_dred\_decode()}}
{\footnotesize\ttfamily int opus\+\_\+decoder\+\_\+dred\+\_\+decode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}}]{st,  }\item[{const \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}}]{dred,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{dred\+\_\+offset,  }\item[{\mbox{\hyperlink{opus__types_8h_acc9ed7cf60479eb81f9648c6ec27dc26}{opus\+\_\+int16}} \texorpdfstring{$\ast$}{*}}]{pcm,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{frame\+\_\+size }\end{DoxyParamCaption})}



Decode audio from an Opus DRED packet with floating point output. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em st} & {\ttfamily Opus\+Decoder\texorpdfstring{$\ast$}{*}}\+: Decoder state \\
\hline
\mbox{\texttt{ in}}  & {\em dred} & {\ttfamily Opus\+DRED\texorpdfstring{$\ast$}{*}}\+: DRED state \\
\hline
\mbox{\texttt{ in}}  & {\em dred\+\_\+offset} & {\ttfamily opus\+\_\+int32}\+: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet). \\
\hline
\mbox{\texttt{ out}}  & {\em pcm} & {\ttfamily opus\+\_\+int16\texorpdfstring{$\ast$}{*}}\+: Output signal (interleaved if 2 channels). length is frame\+\_\+size\texorpdfstring{$\ast$}{*}channels\texorpdfstring{$\ast$}{*}sizeof(opus\+\_\+int16) \\
\hline
\mbox{\texttt{ in}}  & {\em frame\+\_\+size} & Number of samples per channel to decode in {\itshape pcm}. frame\+\_\+size {\bfseries{must}} be a multiple of 2.\+5 ms. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of decoded samples or \doxylink{group__opus__errorcodes}{Error codes} 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_gaa2957ee03a4aadc6eda52c040c5d4ac6}\label{group__opus__decoder_gaa2957ee03a4aadc6eda52c040c5d4ac6} 
\index{Opus Decoder@{Opus Decoder}!opus\_decoder\_dred\_decode\_float@{opus\_decoder\_dred\_decode\_float}}
\index{opus\_decoder\_dred\_decode\_float@{opus\_decoder\_dred\_decode\_float}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decoder\_dred\_decode\_float()}{opus\_decoder\_dred\_decode\_float()}}
{\footnotesize\ttfamily int opus\+\_\+decoder\+\_\+dred\+\_\+decode\+\_\+float (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}}]{st,  }\item[{const \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}}]{dred,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{dred\+\_\+offset,  }\item[{float \texorpdfstring{$\ast$}{*}}]{pcm,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{frame\+\_\+size }\end{DoxyParamCaption})}



Decode audio from an Opus DRED packet with floating point output. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em st} & {\ttfamily Opus\+Decoder\texorpdfstring{$\ast$}{*}}\+: Decoder state \\
\hline
\mbox{\texttt{ in}}  & {\em dred} & {\ttfamily Opus\+DRED\texorpdfstring{$\ast$}{*}}\+: DRED state \\
\hline
\mbox{\texttt{ in}}  & {\em dred\+\_\+offset} & {\ttfamily opus\+\_\+int32}\+: position of the redundancy to decode (in samples before the beginning of the real audio data in the packet). \\
\hline
\mbox{\texttt{ out}}  & {\em pcm} & {\ttfamily float\texorpdfstring{$\ast$}{*}}\+: Output signal (interleaved if 2 channels). length is frame\+\_\+size\texorpdfstring{$\ast$}{*}channels\texorpdfstring{$\ast$}{*}sizeof(float) \\
\hline
\mbox{\texttt{ in}}  & {\em frame\+\_\+size} & Number of samples per channel to decode in {\itshape pcm}. frame\+\_\+size {\bfseries{must}} be a multiple of 2.\+5 ms. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of decoded samples or \doxylink{group__opus__errorcodes}{Error codes} 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_ga659135a16060f85908f63443a2325118}\label{group__opus__decoder_ga659135a16060f85908f63443a2325118} 
\index{Opus Decoder@{Opus Decoder}!opus\_decoder\_get\_nb\_samples@{opus\_decoder\_get\_nb\_samples}}
\index{opus\_decoder\_get\_nb\_samples@{opus\_decoder\_get\_nb\_samples}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decoder\_get\_nb\_samples()}{opus\_decoder\_get\_nb\_samples()}}
{\footnotesize\ttfamily int opus\+\_\+decoder\+\_\+get\+\_\+nb\+\_\+samples (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}}]{dec,  }\item[{const unsigned char}]{packet\mbox{[}$\,$\mbox{]},  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{len }\end{DoxyParamCaption})}



Gets the number of samples of an Opus packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dec} & {\ttfamily Opus\+Decoder\texorpdfstring{$\ast$}{*}}\+: Decoder state \\
\hline
\mbox{\texttt{ in}}  & {\em packet} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Opus packet \\
\hline
\mbox{\texttt{ in}}  & {\em len} & {\ttfamily opus\+\_\+int32}\+: Length of packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of samples 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em OPUS\+\_\+\+BAD\+\_\+\+ARG} & Insufficient data was passed to the function \\
\hline
{\em OPUS\+\_\+\+INVALID\+\_\+\+PACKET} & The compressed data passed is corrupted or of an unsupported type \\
\hline
\end{DoxyRetVals}
\Hypertarget{group__opus__decoder_gac918415b2ee21add75b7f867ce235011}\label{group__opus__decoder_gac918415b2ee21add75b7f867ce235011} 
\index{Opus Decoder@{Opus Decoder}!opus\_decoder\_get\_size@{opus\_decoder\_get\_size}}
\index{opus\_decoder\_get\_size@{opus\_decoder\_get\_size}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decoder\_get\_size()}{opus\_decoder\_get\_size()}}
{\footnotesize\ttfamily int opus\+\_\+decoder\+\_\+get\+\_\+size (\begin{DoxyParamCaption}\item[{int}]{channels }\end{DoxyParamCaption})}



Gets the size of an {\ttfamily Opus\+Decoder} structure. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em channels} & {\ttfamily int}\+: Number of channels. This must be 1 or 2. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The size in bytes. 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_ga939156d1f561c4273d5c62fa9c235a01}\label{group__opus__decoder_ga939156d1f561c4273d5c62fa9c235a01} 
\index{Opus Decoder@{Opus Decoder}!opus\_decoder\_init@{opus\_decoder\_init}}
\index{opus\_decoder\_init@{opus\_decoder\_init}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_decoder\_init()}{opus\_decoder\_init()}}
{\footnotesize\ttfamily int opus\+\_\+decoder\+\_\+init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_ga401d8579958d36094715a6b90cd159a6}{Opus\+Decoder}} \texorpdfstring{$\ast$}{*}}]{st,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{Fs,  }\item[{int}]{channels }\end{DoxyParamCaption})}



Initializes a previously allocated decoder state. 

The state must be at least the size returned by \doxylink{group__opus__decoder_gac918415b2ee21add75b7f867ce235011}{opus\+\_\+decoder\+\_\+get\+\_\+size()}. This is intended for applications which use their own allocator instead of malloc. \begin{DoxySeeAlso}{See also}
\doxylink{group__opus__decoder_ga6c1829854bf2de7b58adae1894ad1e27}{opus\+\_\+decoder\+\_\+create},\doxylink{group__opus__decoder_gac918415b2ee21add75b7f867ce235011}{opus\+\_\+decoder\+\_\+get\+\_\+size} To reset a previously initialized state, use the \doxylink{group__opus__genericctls_gadc74e4fa8bcdf9994187d52d92207337}{OPUS\+\_\+\+RESET\+\_\+\+STATE} CTL. 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em st} & {\ttfamily Opus\+Decoder\texorpdfstring{$\ast$}{*}}\+: Decoder state. \\
\hline
\mbox{\texttt{ in}}  & {\em Fs} & {\ttfamily opus\+\_\+int32}\+: Sampling rate to decode to (Hz). This must be one of 8000, 12000, 16000, 24000, or 48000. \\
\hline
\mbox{\texttt{ in}}  & {\em channels} & {\ttfamily int}\+: Number of channels (1 or 2) to decode \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em \doxylink{group__opus__errorcodes_gaa44cf8a185e1b5cb940ef63eb4f02d21}{OPUS\+\_\+\+OK}} & Success or \doxylink{group__opus__errorcodes}{Error codes} \\
\hline
\end{DoxyRetVals}
\Hypertarget{group__opus__decoder_ga28952b35cc367f2a334789042f8b378b}\label{group__opus__decoder_ga28952b35cc367f2a334789042f8b378b} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_alloc@{opus\_dred\_alloc}}
\index{opus\_dred\_alloc@{opus\_dred\_alloc}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_alloc()}{opus\_dred\_alloc()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*} opus\+\_\+dred\+\_\+alloc (\begin{DoxyParamCaption}\item[{int \texorpdfstring{$\ast$}{*}}]{error }\end{DoxyParamCaption})}



Allocates and initializes a DRED state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em error} & {\ttfamily int\texorpdfstring{$\ast$}{*}}\+: \doxylink{group__opus__errorcodes_gaa44cf8a185e1b5cb940ef63eb4f02d21}{OPUS\+\_\+\+OK} Success or \doxylink{group__opus__errorcodes}{Error codes} \\
\hline
\end{DoxyParams}
\Hypertarget{group__opus__decoder_gaab0b546b5e1bc78da815ff880b410f97}\label{group__opus__decoder_gaab0b546b5e1bc78da815ff880b410f97} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_decoder\_create@{opus\_dred\_decoder\_create}}
\index{opus\_dred\_decoder\_create@{opus\_dred\_decoder\_create}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_decoder\_create()}{opus\_dred\_decoder\_create()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*} opus\+\_\+dred\+\_\+decoder\+\_\+create (\begin{DoxyParamCaption}\item[{int \texorpdfstring{$\ast$}{*}}]{error }\end{DoxyParamCaption})}



Allocates and initializes an Opus\+DREDDecoder state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em error} & {\ttfamily int\texorpdfstring{$\ast$}{*}}\+: \doxylink{group__opus__errorcodes_gaa44cf8a185e1b5cb940ef63eb4f02d21}{OPUS\+\_\+\+OK} Success or \doxylink{group__opus__errorcodes}{Error codes} \\
\hline
\end{DoxyParams}
\Hypertarget{group__opus__decoder_ga2d964d7a37ed634ff6d135c40b05d75f}\label{group__opus__decoder_ga2d964d7a37ed634ff6d135c40b05d75f} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_decoder\_ctl@{opus\_dred\_decoder\_ctl}}
\index{opus\_dred\_decoder\_ctl@{opus\_dred\_decoder\_ctl}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_decoder\_ctl()}{opus\_dred\_decoder\_ctl()}}
{\footnotesize\ttfamily int opus\+\_\+dred\+\_\+decoder\+\_\+ctl (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}}]{dred\+\_\+dec,  }\item[{int}]{request,  }\item[{}]{... }\end{DoxyParamCaption})}



Perform a CTL function on an Opus DRED decoder. 

Generally the request and subsequent arguments are generated by a convenience macro. 
\begin{DoxyParams}{Parameters}
{\em dred\+\_\+dec} & {\ttfamily Opus\+DREDDecoder\texorpdfstring{$\ast$}{*}}\+: DRED Decoder state. \\
\hline
{\em request} & This and all remaining parameters should be replaced by one of the convenience macros in \doxylink{group__opus__genericctls}{Generic CTLs} or \doxylink{group__opus__decoderctls}{Decoder related CTLs}. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{group__opus__genericctls}{Generic CTLs} 

\doxylink{group__opus__decoderctls}{Decoder related CTLs} 
\end{DoxySeeAlso}
\Hypertarget{group__opus__decoder_ga21ef5755a25762a69665b1883382292e}\label{group__opus__decoder_ga21ef5755a25762a69665b1883382292e} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_decoder\_destroy@{opus\_dred\_decoder\_destroy}}
\index{opus\_dred\_decoder\_destroy@{opus\_dred\_decoder\_destroy}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_decoder\_destroy()}{opus\_dred\_decoder\_destroy()}}
{\footnotesize\ttfamily void opus\+\_\+dred\+\_\+decoder\+\_\+destroy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}}]{dec }\end{DoxyParamCaption})}



Frees an {\ttfamily Opus\+DREDDecoder} allocated by \doxylink{group__opus__decoder_gaab0b546b5e1bc78da815ff880b410f97}{opus\+\_\+dred\+\_\+decoder\+\_\+create()}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dec} & {\ttfamily Opus\+DREDDecoder\texorpdfstring{$\ast$}{*}}\+: State to be freed. \\
\hline
\end{DoxyParams}
\Hypertarget{group__opus__decoder_ga58665700bd65a64b4cb811dbd4db1e2a}\label{group__opus__decoder_ga58665700bd65a64b4cb811dbd4db1e2a} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_decoder\_get\_size@{opus\_dred\_decoder\_get\_size}}
\index{opus\_dred\_decoder\_get\_size@{opus\_dred\_decoder\_get\_size}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_decoder\_get\_size()}{opus\_dred\_decoder\_get\_size()}}
{\footnotesize\ttfamily int opus\+\_\+dred\+\_\+decoder\+\_\+get\+\_\+size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Gets the size of an {\ttfamily Opus\+DREDDecoder} structure. 

\begin{DoxyReturn}{Returns}
The size in bytes. 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_gaefbe97140acff521c3b2d4a1b00b33d5}\label{group__opus__decoder_gaefbe97140acff521c3b2d4a1b00b33d5} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_decoder\_init@{opus\_dred\_decoder\_init}}
\index{opus\_dred\_decoder\_init@{opus\_dred\_decoder\_init}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_decoder\_init()}{opus\_dred\_decoder\_init()}}
{\footnotesize\ttfamily int opus\+\_\+dred\+\_\+decoder\+\_\+init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}}]{dec }\end{DoxyParamCaption})}



Initializes an {\ttfamily Opus\+DREDDecoder} state. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dec} & {\ttfamily Opus\+DREDDecoder\texorpdfstring{$\ast$}{*}}\+: State to be initialized. \\
\hline
\end{DoxyParams}
\Hypertarget{group__opus__decoder_ga935b58a831738b44afd2ed42096f0ee9}\label{group__opus__decoder_ga935b58a831738b44afd2ed42096f0ee9} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_free@{opus\_dred\_free}}
\index{opus\_dred\_free@{opus\_dred\_free}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_free()}{opus\_dred\_free()}}
{\footnotesize\ttfamily void opus\+\_\+dred\+\_\+free (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}}]{dec }\end{DoxyParamCaption})}



Frees an {\ttfamily Opus\+DRED} allocated by opus\+\_\+dred\+\_\+create(). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dec} & {\ttfamily Opus\+DRED\texorpdfstring{$\ast$}{*}}\+: State to be freed. \\
\hline
\end{DoxyParams}
\Hypertarget{group__opus__decoder_gaa7c7210fda039d466bcbd28c9a9b081f}\label{group__opus__decoder_gaa7c7210fda039d466bcbd28c9a9b081f} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_get\_size@{opus\_dred\_get\_size}}
\index{opus\_dred\_get\_size@{opus\_dred\_get\_size}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_get\_size()}{opus\_dred\_get\_size()}}
{\footnotesize\ttfamily int opus\+\_\+dred\+\_\+get\+\_\+size (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Gets the size of an {\ttfamily Opus\+DRED} structure. 

\begin{DoxyReturn}{Returns}
The size in bytes. 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_ga6674a62897092f51183a792669b99c6e}\label{group__opus__decoder_ga6674a62897092f51183a792669b99c6e} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_parse@{opus\_dred\_parse}}
\index{opus\_dred\_parse@{opus\_dred\_parse}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_parse()}{opus\_dred\_parse()}}
{\footnotesize\ttfamily int opus\+\_\+dred\+\_\+parse (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}}]{dred\+\_\+dec,  }\item[{\mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}}]{dred,  }\item[{const unsigned char \texorpdfstring{$\ast$}{*}}]{data,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{len,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{max\+\_\+dred\+\_\+samples,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{sampling\+\_\+rate,  }\item[{int \texorpdfstring{$\ast$}{*}}]{dred\+\_\+end,  }\item[{int}]{defer\+\_\+processing }\end{DoxyParamCaption})}



Decode an Opus DRED packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dred\+\_\+dec} & {\ttfamily Opus\+DRED\texorpdfstring{$\ast$}{*}}\+: DRED Decoder state \\
\hline
\mbox{\texttt{ in}}  & {\em dred} & {\ttfamily Opus\+DRED\texorpdfstring{$\ast$}{*}}\+: DRED state \\
\hline
\mbox{\texttt{ in}}  & {\em data} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Input payload \\
\hline
\mbox{\texttt{ in}}  & {\em len} & {\ttfamily opus\+\_\+int32}\+: Number of bytes in payload \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+dred\+\_\+samples} & {\ttfamily opus\+\_\+int32}\+: Maximum number of DRED samples that may be needed (if available in the packet). \\
\hline
\mbox{\texttt{ in}}  & {\em sampling\+\_\+rate} & {\ttfamily opus\+\_\+int32}\+: Sampling rate used for max\+\_\+dred\+\_\+samples argument. Needs not match the actual sampling rate of the decoder. \\
\hline
\mbox{\texttt{ out}}  & {\em dred\+\_\+end} & {\ttfamily opus\+\_\+int32\texorpdfstring{$\ast$}{*}}\+: Number of non-\/encoded (silence) samples between the DRED timestamp and the last DRED sample. \\
\hline
\mbox{\texttt{ in}}  & {\em defer\+\_\+processing} & {\ttfamily int}\+: Flag (0 or 1). If set to one, the CPU-\/intensive part of the DRED decoding is deferred until \doxylink{group__opus__decoder_gaf25125c27783db366f239b7ab3633601}{opus\+\_\+dred\+\_\+process()} is called. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Offset (positive) of the first decoded DRED samples, zero if no DRED is present, or \doxylink{group__opus__errorcodes}{Error codes} 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_gaf25125c27783db366f239b7ab3633601}\label{group__opus__decoder_gaf25125c27783db366f239b7ab3633601} 
\index{Opus Decoder@{Opus Decoder}!opus\_dred\_process@{opus\_dred\_process}}
\index{opus\_dred\_process@{opus\_dred\_process}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_dred\_process()}{opus\_dred\_process()}}
{\footnotesize\ttfamily int opus\+\_\+dred\+\_\+process (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__opus__decoder_gaa306779b7ccaf41a3034df368477782c}{Opus\+DREDDecoder}} \texorpdfstring{$\ast$}{*}}]{dred\+\_\+dec,  }\item[{const \mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}}]{src,  }\item[{\mbox{\hyperlink{group__opus__decoder_ga5b9093a1d0e104dbd1eb3a7ec836d81b}{Opus\+DRED}} \texorpdfstring{$\ast$}{*}}]{dst }\end{DoxyParamCaption})}



Finish decoding an Opus DRED packet. 

The function only needs to be called if \doxylink{group__opus__decoder_ga6674a62897092f51183a792669b99c6e}{opus\+\_\+dred\+\_\+parse()} was called with defer\+\_\+processing=1. The source and destination will often be the same DRED state. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dred\+\_\+dec} & {\ttfamily Opus\+DRED\texorpdfstring{$\ast$}{*}}\+: DRED Decoder state \\
\hline
\mbox{\texttt{ in}}  & {\em src} & {\ttfamily Opus\+DRED\texorpdfstring{$\ast$}{*}}\+: Source DRED state to start the processing from. \\
\hline
\mbox{\texttt{ out}}  & {\em dst} & {\ttfamily Opus\+DRED\texorpdfstring{$\ast$}{*}}\+: Destination DRED state to store the updated state after processing. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\doxylink{group__opus__errorcodes}{Error codes} 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_ga89b9375b6ff5e15f07fdc5d0cf4f0053}\label{group__opus__decoder_ga89b9375b6ff5e15f07fdc5d0cf4f0053} 
\index{Opus Decoder@{Opus Decoder}!opus\_packet\_get\_bandwidth@{opus\_packet\_get\_bandwidth}}
\index{opus\_packet\_get\_bandwidth@{opus\_packet\_get\_bandwidth}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_packet\_get\_bandwidth()}{opus\_packet\_get\_bandwidth()}}
{\footnotesize\ttfamily int opus\+\_\+packet\+\_\+get\+\_\+bandwidth (\begin{DoxyParamCaption}\item[{const unsigned char \texorpdfstring{$\ast$}{*}}]{data }\end{DoxyParamCaption})}



Gets the bandwidth of an Opus packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em data} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Opus packet \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em OPUS\+\_\+\+BANDWIDTH\+\_\+\+NARROWBAND} & Narrowband (4k\+Hz bandpass) \\
\hline
{\em OPUS\+\_\+\+BANDWIDTH\+\_\+\+MEDIUMBAND} & Mediumband (6k\+Hz bandpass) \\
\hline
{\em OPUS\+\_\+\+BANDWIDTH\+\_\+\+WIDEBAND} & Wideband (8k\+Hz bandpass) \\
\hline
{\em OPUS\+\_\+\+BANDWIDTH\+\_\+\+SUPERWIDEBAND} & Superwideband (12k\+Hz bandpass) \\
\hline
{\em OPUS\+\_\+\+BANDWIDTH\+\_\+\+FULLBAND} & Fullband (20k\+Hz bandpass) \\
\hline
{\em OPUS\+\_\+\+INVALID\+\_\+\+PACKET} & The compressed data passed is corrupted or of an unsupported type \\
\hline
\end{DoxyRetVals}
\Hypertarget{group__opus__decoder_ga4209376ddf8cc3379767e1749e1ef26d}\label{group__opus__decoder_ga4209376ddf8cc3379767e1749e1ef26d} 
\index{Opus Decoder@{Opus Decoder}!opus\_packet\_get\_nb\_channels@{opus\_packet\_get\_nb\_channels}}
\index{opus\_packet\_get\_nb\_channels@{opus\_packet\_get\_nb\_channels}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_packet\_get\_nb\_channels()}{opus\_packet\_get\_nb\_channels()}}
{\footnotesize\ttfamily int opus\+\_\+packet\+\_\+get\+\_\+nb\+\_\+channels (\begin{DoxyParamCaption}\item[{const unsigned char \texorpdfstring{$\ast$}{*}}]{data }\end{DoxyParamCaption})}



Gets the number of channels from an Opus packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em data} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Opus packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of channels 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em OPUS\+\_\+\+INVALID\+\_\+\+PACKET} & The compressed data passed is corrupted or of an unsupported type \\
\hline
\end{DoxyRetVals}
\Hypertarget{group__opus__decoder_ga064cb2ed9e77a934cd7db6c13b02c584}\label{group__opus__decoder_ga064cb2ed9e77a934cd7db6c13b02c584} 
\index{Opus Decoder@{Opus Decoder}!opus\_packet\_get\_nb\_frames@{opus\_packet\_get\_nb\_frames}}
\index{opus\_packet\_get\_nb\_frames@{opus\_packet\_get\_nb\_frames}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_packet\_get\_nb\_frames()}{opus\_packet\_get\_nb\_frames()}}
{\footnotesize\ttfamily int opus\+\_\+packet\+\_\+get\+\_\+nb\+\_\+frames (\begin{DoxyParamCaption}\item[{const unsigned char}]{packet\mbox{[}$\,$\mbox{]},  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{len }\end{DoxyParamCaption})}



Gets the number of frames in an Opus packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em packet} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Opus packet \\
\hline
\mbox{\texttt{ in}}  & {\em len} & {\ttfamily opus\+\_\+int32}\+: Length of packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of frames 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em OPUS\+\_\+\+BAD\+\_\+\+ARG} & Insufficient data was passed to the function \\
\hline
{\em OPUS\+\_\+\+INVALID\+\_\+\+PACKET} & The compressed data passed is corrupted or of an unsupported type \\
\hline
\end{DoxyRetVals}
\Hypertarget{group__opus__decoder_ga3cfec8b0bed7789ebd88c3b3370d337b}\label{group__opus__decoder_ga3cfec8b0bed7789ebd88c3b3370d337b} 
\index{Opus Decoder@{Opus Decoder}!opus\_packet\_get\_nb\_samples@{opus\_packet\_get\_nb\_samples}}
\index{opus\_packet\_get\_nb\_samples@{opus\_packet\_get\_nb\_samples}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_packet\_get\_nb\_samples()}{opus\_packet\_get\_nb\_samples()}}
{\footnotesize\ttfamily int opus\+\_\+packet\+\_\+get\+\_\+nb\+\_\+samples (\begin{DoxyParamCaption}\item[{const unsigned char}]{packet\mbox{[}$\,$\mbox{]},  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{len,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{Fs }\end{DoxyParamCaption})}



Gets the number of samples of an Opus packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em packet} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Opus packet \\
\hline
\mbox{\texttt{ in}}  & {\em len} & {\ttfamily opus\+\_\+int32}\+: Length of packet \\
\hline
\mbox{\texttt{ in}}  & {\em Fs} & {\ttfamily opus\+\_\+int32}\+: Sampling rate in Hz. This must be a multiple of 400, or inaccurate results will be returned. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of samples 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em OPUS\+\_\+\+BAD\+\_\+\+ARG} & Insufficient data was passed to the function \\
\hline
{\em OPUS\+\_\+\+INVALID\+\_\+\+PACKET} & The compressed data passed is corrupted or of an unsupported type \\
\hline
\end{DoxyRetVals}
\Hypertarget{group__opus__decoder_gab2a955acced631c6cb7876bbdc7953d4}\label{group__opus__decoder_gab2a955acced631c6cb7876bbdc7953d4} 
\index{Opus Decoder@{Opus Decoder}!opus\_packet\_get\_samples\_per\_frame@{opus\_packet\_get\_samples\_per\_frame}}
\index{opus\_packet\_get\_samples\_per\_frame@{opus\_packet\_get\_samples\_per\_frame}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_packet\_get\_samples\_per\_frame()}{opus\_packet\_get\_samples\_per\_frame()}}
{\footnotesize\ttfamily int opus\+\_\+packet\+\_\+get\+\_\+samples\+\_\+per\+\_\+frame (\begin{DoxyParamCaption}\item[{const unsigned char \texorpdfstring{$\ast$}{*}}]{data,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{Fs }\end{DoxyParamCaption})}



Gets the number of samples per frame from an Opus packet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em data} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Opus packet. This must contain at least one byte of data. \\
\hline
\mbox{\texttt{ in}}  & {\em Fs} & {\ttfamily opus\+\_\+int32}\+: Sampling rate in Hz. This must be a multiple of 400, or inaccurate results will be returned. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of samples per frame. 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_gae142ef5b2a6c228f8b329646c9403101}\label{group__opus__decoder_gae142ef5b2a6c228f8b329646c9403101} 
\index{Opus Decoder@{Opus Decoder}!opus\_packet\_has\_lbrr@{opus\_packet\_has\_lbrr}}
\index{opus\_packet\_has\_lbrr@{opus\_packet\_has\_lbrr}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_packet\_has\_lbrr()}{opus\_packet\_has\_lbrr()}}
{\footnotesize\ttfamily int opus\+\_\+packet\+\_\+has\+\_\+lbrr (\begin{DoxyParamCaption}\item[{const unsigned char}]{packet\mbox{[}$\,$\mbox{]},  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{len }\end{DoxyParamCaption})}



Checks whether an Opus packet has LBRR. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em packet} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Opus packet \\
\hline
\mbox{\texttt{ in}}  & {\em len} & {\ttfamily opus\+\_\+int32}\+: Length of packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 is LBRR is present, 0 otherwise 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em OPUS\+\_\+\+INVALID\+\_\+\+PACKET} & The compressed data passed is corrupted or of an unsupported type \\
\hline
\end{DoxyRetVals}
\Hypertarget{group__opus__decoder_ga9d0054936a3345865632b04729cd368c}\label{group__opus__decoder_ga9d0054936a3345865632b04729cd368c} 
\index{Opus Decoder@{Opus Decoder}!opus\_packet\_parse@{opus\_packet\_parse}}
\index{opus\_packet\_parse@{opus\_packet\_parse}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_packet\_parse()}{opus\_packet\_parse()}}
{\footnotesize\ttfamily int opus\+\_\+packet\+\_\+parse (\begin{DoxyParamCaption}\item[{const unsigned char \texorpdfstring{$\ast$}{*}}]{data,  }\item[{\mbox{\hyperlink{opus__types_8h_aa4d309d6f80b99dbabebc8f98879ab9a}{opus\+\_\+int32}}}]{len,  }\item[{unsigned char \texorpdfstring{$\ast$}{*}}]{out\+\_\+toc,  }\item[{const unsigned char \texorpdfstring{$\ast$}{*}}]{frames\mbox{[}48\mbox{]},  }\item[{\mbox{\hyperlink{opus__types_8h_acc9ed7cf60479eb81f9648c6ec27dc26}{opus\+\_\+int16}}}]{size\mbox{[}48\mbox{]},  }\item[{int \texorpdfstring{$\ast$}{*}}]{payload\+\_\+offset }\end{DoxyParamCaption})}



Parse an opus packet into one or more frames. 

Opus\+\_\+decode will perform this operation internally so most applications do not need to use this function. This function does not copy the frames, the returned pointers are pointers into the input packet. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em data} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: Opus packet to be parsed \\
\hline
\mbox{\texttt{ in}}  & {\em len} & {\ttfamily opus\+\_\+int32}\+: size of data \\
\hline
\mbox{\texttt{ out}}  & {\em out\+\_\+toc} & {\ttfamily char\texorpdfstring{$\ast$}{*}}\+: TOC pointer \\
\hline
\mbox{\texttt{ out}}  & {\em frames} & {\ttfamily char\texorpdfstring{$\ast$}{*}\mbox{[}48\mbox{]}} encapsulated frames \\
\hline
\mbox{\texttt{ out}}  & {\em size} & {\ttfamily opus\+\_\+int16\mbox{[}48\mbox{]}} sizes of the encapsulated frames \\
\hline
\mbox{\texttt{ out}}  & {\em payload\+\_\+offset} & {\ttfamily int\texorpdfstring{$\ast$}{*}}\+: returns the position of the payload within the packet (in bytes) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of frames 
\end{DoxyReturn}
\Hypertarget{group__opus__decoder_gaff99598b352e8939dded08d96e125e0b}\label{group__opus__decoder_gaff99598b352e8939dded08d96e125e0b} 
\index{Opus Decoder@{Opus Decoder}!opus\_pcm\_soft\_clip@{opus\_pcm\_soft\_clip}}
\index{opus\_pcm\_soft\_clip@{opus\_pcm\_soft\_clip}!Opus Decoder@{Opus Decoder}}
\doxysubsubsection{\texorpdfstring{opus\_pcm\_soft\_clip()}{opus\_pcm\_soft\_clip()}}
{\footnotesize\ttfamily void opus\+\_\+pcm\+\_\+soft\+\_\+clip (\begin{DoxyParamCaption}\item[{float \texorpdfstring{$\ast$}{*}}]{pcm,  }\item[{int}]{frame\+\_\+size,  }\item[{int}]{channels,  }\item[{float \texorpdfstring{$\ast$}{*}}]{softclip\+\_\+mem }\end{DoxyParamCaption})}



Applies soft-\/clipping to bring a float signal within the \mbox{[}-\/1,1\mbox{]} range. 

If the signal is already in that range, nothing is done. If there are values outside of \mbox{[}-\/1,1\mbox{]}, then the signal is clipped as smoothly as possible to both fit in the range and avoid creating excessive distortion in the process. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em pcm} & {\ttfamily float\texorpdfstring{$\ast$}{*}}\+: Input PCM and modified PCM \\
\hline
\mbox{\texttt{ in}}  & {\em frame\+\_\+size} & {\ttfamily int} Number of samples per channel to process \\
\hline
\mbox{\texttt{ in}}  & {\em channels} & {\ttfamily int}\+: Number of channels \\
\hline
\mbox{\texttt{ in,out}}  & {\em softclip\+\_\+mem} & {\ttfamily float\texorpdfstring{$\ast$}{*}}\+: State memory for the soft clipping process (one float per channel, initialized to zero) \\
\hline
\end{DoxyParams}
